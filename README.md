# JavaCipher

  *Шифрование* - Это процесс преобразования исходного сообщения M (называемого открытым текстом) в форму M' (зашифрованный текст или шифртекст). При этом провести обратное преобразование M' в M возможно только обладая некоторой дополнительной информацией, называемой `ключом`.

  ## Алгоритмы делятся на две большие группы:
*1. Симметричные* (традиционное шифрование).

#### А симметричные делятся еще на три класса:

- *Подстановочные алгоритмы.*
  - Каждый символ (или последовательность символов) исходного сообщения заменяются другим символом (или другой последовательностью символов).

- *Перестановочные алгоритмы.*
  - В перестановочных алгоритмах символы открытого текста изменяют порядок следования в соответствии с правилом, которое определяется ключом.
    
- *Алгоритмы, использующие подстановку и перестановку (современный тип).*


 В симметричных алгоритмах шифрования один и тот же ключ K используется для того, чтобы зашифровать сообщение и для его последующей расшифровки. Таким образом, и *отправитель* и *получатель* сообщения должны распологать одним и тем же ключом.


*2. Ассиметричные* (с открытым и закрытым ключом).

 Предполагает использование двух ключей - открытого и закрытого. 
 
 Открытый (публичный) ключ применяется для шифрования информации и может передаваться по незащищенным каналам.

 Закрытый (приватный) ключ применяется для расшифровки данных, зашифрованных открытым ключом. Открытый и закрытый ключи - это очень большие числа, связанные друг с другом определенной функцией, но так, что, зная одно, крайне сложно вычислить второе.

 ## Шифр Плейфера (Playfair Cipher)

  Шифр Плейфера - Это ручная симметричная техника шифрования, то есть для шифрования и расшифрования применяется один и тот же криптографический ключ. В ней была впервые применена техника использования `биграмм` **(два слова, которые в тексте являются соседними)**, вместо одиночных символов, как в шифре подстановки и в более сложных системах шифрования Вижнера.

### Принцип шифрования

  Шифр использует матрицу 5x5 для латинского алфавита (6x6 для русского), содержащую ключевое слово или фразу.

  Есть исходное сообщение: `HELL`

 - Если в сообщении есть символ 'J' - заменить его на символ 'I'
    
- Если в данном сообщении есть повторяющиеся, рядом стоящие символы, то между ними должен стоять символ 'X'

Получим сообщение `HE LX L`

Далее разделяем сообщение по 2 символа.

Получим сообщение: `HE LX L`

Если сообщение нечётное - добавить в конец символ 'X'

Получим сообщение: `HE LX LX`

Далее создаём какой-либо ключ и заносим его в матрицу алфавита.

Используем ключ **SOMETHING**.

Получится подобная матрица:

<table>
  <tr>
    <td>'S'</td>
    <td>'O'</td>
    <td>'M'</td>
    <td>'E'</td>
    <td>'T'</td>
  </tr>
  <tr>
    <td>'H'</td>
    <td>'I'</td>
    <td>'N'</td>
    <td>'G'</td>
    <td>'A'</td>
  </tr>
  <tr>
    <td>'B'</td>
    <td>'C'</td>
    <td>'D'</td>
    <td>'F'</td>
    <td>'K'</td>
  </tr>
  <tr>
    <td>'L'</td>
    <td>'P'</td>
    <td>'Q'</td>
    <td>'R'</td>
    <td>'U'</td>
  </tr>
  <tr>
    <td>'V'</td>
    <td>'W'</td>
    <td>'X'</td>
    <td>'Y'</td>
    <td>'Z'</td>
  </tr>
</table>

Далее идёт одновременно три способа шифрования биграмм:

1. Символы в одном столбце |&darr;| wrap around.
2. Символы в одной строке |&rarr;| wrap around.
3. Символы образуют прямоугольник |&#8596;| SWAP.
  
В итоге мы получаем следующее: GS QV QV.

Складываем все символы в одну строку и получаем зашифрованное сообщение: `GSQVQV`

Еще примеров можно посмотреть здесь: [Тык](https://people.eecs.berkeley.edu/~bh/pdf/v1ch12.pdf)
